{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-cli Command-line interface for Laminas projects Installation Via Composer Install the library using Composer : $ composer require laminas/laminas-cli Usage $ vendor/bin/laminas [command-name] Custom command if you want to add any command for Laminas MVC or Mezzio application just implement normal Symfony console command and add register the command for the cli: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyCommand::class, ], ], ]; Please remember that if command has some dependencies you should register also factory within the container, for example: return [ 'dependencies' => [ 'factories' => [ MyCommand::class => MyCommandFactory::class, ], ], ];","title":"Home"},{"location":"#laminas-cli","text":"Command-line interface for Laminas projects","title":"laminas-cli"},{"location":"#installation","text":"","title":"Installation"},{"location":"#usage","text":"$ vendor/bin/laminas [command-name]","title":"Usage"},{"location":"#custom-command","text":"if you want to add any command for Laminas MVC or Mezzio application just implement normal Symfony console command and add register the command for the cli: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyCommand::class, ], ], ]; Please remember that if command has some dependencies you should register also factory within the container, for example: return [ 'dependencies' => [ 'factories' => [ MyCommand::class => MyCommandFactory::class, ], ], ];","title":"Custom command"},{"location":"autocompletion/","text":"Autocompletion laminas-cli does not provide autocompletion out of the box. However, it is possible to add autocompletion via a third-party package, bamarni/symfony-console-autocomplete . This package provides completion for any symfony/console-based application, which means it will work with laminas-cli as well. Installation First, install the autocompletion package as a global tool: composer global require bamarni/symfony-console-autocomplete Configuration Second, you will need to add configuration for your shell. We will add three things: Configuration to ensure your Composer script path is in your $PATH . An alias for the laminas-cli script. This is done so that autocompletion is given for the project in which you have it installed. The autocompletion script. For most shells, you can use the following: # Skip this step if you already have the Composer script path in your $PATH export PATH=$(composer global config home)/vendor/bin:$PATH # Alias laminas-cli to current path alias laminas=./vendor/bin/laminas # Add the autocompletion script, informing it to also complete laminas eval \"$(symfony-autocomplete --aliases laminas)\" The above should be placed in your shell configuration file: For BASH users, $HOME/.bashrc For ZSH users, $HOME/.zshrc For FISH users, $HOME/.config/fish/config.fish Once the changes have been made, either open a new terminal, or source your shell configuration: For BASH users, source $HOME/.bashrc For ZSH users, source $HOME/.zshrc For FISH users, source $HOME/.config/fish/config.fish Usage Once installation and configuration of the tooling is complete and you are either in a new terminal or have sourced the changes to your shell configuration, you can invoke autocompletion by pressing <Tab> after typing the laminas command at the prompt: $ laminas <TAB>","title":"Autocompletion"},{"location":"autocompletion/#autocompletion","text":"laminas-cli does not provide autocompletion out of the box. However, it is possible to add autocompletion via a third-party package, bamarni/symfony-console-autocomplete . This package provides completion for any symfony/console-based application, which means it will work with laminas-cli as well.","title":"Autocompletion"},{"location":"autocompletion/#installation","text":"First, install the autocompletion package as a global tool: composer global require bamarni/symfony-console-autocomplete","title":"Installation"},{"location":"autocompletion/#configuration","text":"Second, you will need to add configuration for your shell. We will add three things: Configuration to ensure your Composer script path is in your $PATH . An alias for the laminas-cli script. This is done so that autocompletion is given for the project in which you have it installed. The autocompletion script. For most shells, you can use the following: # Skip this step if you already have the Composer script path in your $PATH export PATH=$(composer global config home)/vendor/bin:$PATH # Alias laminas-cli to current path alias laminas=./vendor/bin/laminas # Add the autocompletion script, informing it to also complete laminas eval \"$(symfony-autocomplete --aliases laminas)\" The above should be placed in your shell configuration file: For BASH users, $HOME/.bashrc For ZSH users, $HOME/.zshrc For FISH users, $HOME/.config/fish/config.fish Once the changes have been made, either open a new terminal, or source your shell configuration: For BASH users, source $HOME/.bashrc For ZSH users, source $HOME/.zshrc For FISH users, source $HOME/.config/fish/config.fish","title":"Configuration"},{"location":"autocompletion/#usage","text":"Once installation and configuration of the tooling is complete and you are either in a new terminal or have sourced the changes to your shell configuration, you can invoke autocompletion by pressing <Tab> after typing the laminas command at the prompt: $ laminas <TAB>","title":"Usage"},{"location":"command-chains/","text":"Command chains Sometimes you may want to execute another command straight after the successful completion of another command. As an example, consider the following two command classes: namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class FirstCommand extends Command { /** @var string */ protected static $defaultName = 'first-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('name', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('First command: ' . $input->getOption('name')); return 0; } } namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class SecondCommand extends Command { /** @var string */ protected static $defaultName = 'second-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('module', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('Second command: ' . $input->getOption('module')); return 0; } } We can expose each to laminas-cli, and also create a chain , whereby when the first command finishes execution, it will then invoke the second: namespace MyApp\\Command; return [ 'laminas-cli' => [ 'commands' => [ 'first-command' => Command\\FirstCommand::class, 'second-command' => Command\\SecondCommand::class, ], 'chains' => [ Command\\FirstCommand::class => [ Command\\SecondCommand::class => ['--name' => '--module'], ], ], ], ]; \"chains\" configuration options We discuss chain configuration in more detail below . Running ./vendor/bin/laminas first-command will result with: $ ./vendor/bin/laminas first-command --name=Foo First command: Foo Executing second-command. Do you want to continue? [Y] yes, continue [s] skip this command, [n] no, break > yes, continue Second command: Foo Please note that only successful result of the first command will trigger the second command. The final result (exit code) of the chained commands will be the result of the last executed command. If a command in the middle of the chain results in a failure status, execution will halt with that command, and its status will be returned. Chain configuration Chain configuration is under the \"chains\" section of the \"laminas-cli\" configuration: <?php return [ 'laminas-cli' => [ 'chains' => [ /* . . . */ ], ], ]; The configuration is expected to be an associative array mapping command names you have previously defined in the \"commands\" section of the \"laminas-cli\" configuration, and the value is an associative array: 'chains' => [ COMMAND_CLASS_NAME => CHAINED_COMMANDS ], The chained commands ( CHAINED_COMMANDS ) are themselves an associative array, where the key is the name of a command you have already defined in the \"commands\" section of the \"laminas-cli\" configuration, and the value is an associative array: 'chains' => [ COMMAND_CLASS_NAME => [ CHAINED_COMMAND_CLASS_NAME => INPUT_MAPPER, ], ], An input mapper ( INPUT_MAPPER ) can be one of two things: a string class name of an implemention of Laminas\\Cli\\Input\\Mapper\\InputMapperInterface an array specification Most commonly, you will use an array specification. In this case, items can take two forms: a key/value pair, where the key is the option or argument from the previous command, and the value is the option or argument by which to provide the value to the chained command. an array, with a single key/value pair of the option or argument name on the chained command, and the value to use with it. As a visualization: 'chains' => [ COMMAND_CLASS_NAME => [ 'argument-on-previous-command' => 'argument-on-this-command', '--option-on-previous-command' => '--option-on-this-command', ['an-argument-on-this-command' => 'argument value to supply'], ['--an-option-on-this-command' => 'option value to supply'], ], ], When specifying options, the -- prefix should be used with the option names, just like you'd invoke them from the command line if you were to call the command by itself. Chain command input mapper example If we return to the original example from the first section of this page: namespace MyApp\\Command; return [ 'laminas-cli' => [ 'commands' => [ 'first-command' => Command\\FirstCommand::class, 'second-command' => Command\\SecondCommand::class, ], 'chains' => [ Command\\FirstCommand::class => [ Command\\SecondCommand::class => ['--name' => '--module'], ], ], ], ]; We have defined two commands, FirstCommand and SecondCommand . FirstCommand defines the option --name , while SecondCommand defines the option --module . In the above configuration, we indicate that when we call FirstCommand , we want to start a command chain that also invokes SecondCommand . When it does so, it should take the value provided via the --name option and pass that value to the SecondCommand --module option. In effect, that would be similar to calling the following commands in sequence: $ ./vendor/bin/laminas first-command --name Foo $ ./vendor/bin/laminas second-command --module Foo Since FirstCommand now provides a chain, we can call: $ ./vendor/bin/laminas first-command --name Foo and Foo will be passed for the --module option when SecondCommand is invoked as part of the chain. InputMapperInterface As noted in the previous section, you can provide a string class name of a Laminas\\Cli\\Input\\Mapper\\InputMapperInterface implementation to use in order to map arguments and options from one command to another. That interface defines one method: namespace Laminas\\Cli\\Input\\Mapper; use Symfony\\Component\\Console\\Input\\InputInterface; interface InputMapperInterface { public function __invoke(InputInterface $input): array; } The return value should be an associative array mapping arguments and options to the values they contain, suitable for use with Symfony\\Component\\Console\\Input\\ArrayInput ( see symfony/console documentation for details ); Example The initial section of this page [ 'name' => 'module', // adds \"module\" argument to the next command call with the value of \"name\" argument from the previous command '--mode' => '--type', // adds \"--type\" option to the next command call with the value of \"--mode\" option from the previous command ['additional-arg' => 'arg-value'], // adds \"additional-arg\" argument to the next command call with the value \"arg-value\" ['--additional-opt' => 'opt-value'], // adds \"--additional-opt\" option to the next command call with the value \"opt-value\" ], It is also possible to provide class name (string) which implements Laminas\\Cli\\Input\\Mapper\\InputMapperInterface if you need more customised mapper between input of the previous and next command.","title":"Command Chains"},{"location":"command-chains/#command-chains","text":"Sometimes you may want to execute another command straight after the successful completion of another command. As an example, consider the following two command classes: namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class FirstCommand extends Command { /** @var string */ protected static $defaultName = 'first-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('name', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('First command: ' . $input->getOption('name')); return 0; } } namespace MyApp\\Command; use Symfony\\Component\\Console\\Command\\Command; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Output\\OutputInterface; class SecondCommand extends Command { /** @var string */ protected static $defaultName = 'second-command'; protected function configure() : void { $this->setName(self::$defaultName); $this->addOption('module', null, InputOption::VALUE_REQUIRED, 'Module name'); } protected function execute(InputInterface $input, OutputInterface $output) : int { $output->writeln('Second command: ' . $input->getOption('module')); return 0; } } We can expose each to laminas-cli, and also create a chain , whereby when the first command finishes execution, it will then invoke the second: namespace MyApp\\Command; return [ 'laminas-cli' => [ 'commands' => [ 'first-command' => Command\\FirstCommand::class, 'second-command' => Command\\SecondCommand::class, ], 'chains' => [ Command\\FirstCommand::class => [ Command\\SecondCommand::class => ['--name' => '--module'], ], ], ], ];","title":"Command chains"},{"location":"command-chains/#chain-configuration","text":"Chain configuration is under the \"chains\" section of the \"laminas-cli\" configuration: <?php return [ 'laminas-cli' => [ 'chains' => [ /* . . . */ ], ], ]; The configuration is expected to be an associative array mapping command names you have previously defined in the \"commands\" section of the \"laminas-cli\" configuration, and the value is an associative array: 'chains' => [ COMMAND_CLASS_NAME => CHAINED_COMMANDS ], The chained commands ( CHAINED_COMMANDS ) are themselves an associative array, where the key is the name of a command you have already defined in the \"commands\" section of the \"laminas-cli\" configuration, and the value is an associative array: 'chains' => [ COMMAND_CLASS_NAME => [ CHAINED_COMMAND_CLASS_NAME => INPUT_MAPPER, ], ], An input mapper ( INPUT_MAPPER ) can be one of two things: a string class name of an implemention of Laminas\\Cli\\Input\\Mapper\\InputMapperInterface an array specification Most commonly, you will use an array specification. In this case, items can take two forms: a key/value pair, where the key is the option or argument from the previous command, and the value is the option or argument by which to provide the value to the chained command. an array, with a single key/value pair of the option or argument name on the chained command, and the value to use with it. As a visualization: 'chains' => [ COMMAND_CLASS_NAME => [ 'argument-on-previous-command' => 'argument-on-this-command', '--option-on-previous-command' => '--option-on-this-command', ['an-argument-on-this-command' => 'argument value to supply'], ['--an-option-on-this-command' => 'option value to supply'], ], ], When specifying options, the -- prefix should be used with the option names, just like you'd invoke them from the command line if you were to call the command by itself.","title":"Chain configuration"},{"location":"command-chains/#inputmapperinterface","text":"As noted in the previous section, you can provide a string class name of a Laminas\\Cli\\Input\\Mapper\\InputMapperInterface implementation to use in order to map arguments and options from one command to another. That interface defines one method: namespace Laminas\\Cli\\Input\\Mapper; use Symfony\\Component\\Console\\Input\\InputInterface; interface InputMapperInterface { public function __invoke(InputInterface $input): array; } The return value should be an associative array mapping arguments and options to the values they contain, suitable for use with Symfony\\Component\\Console\\Input\\ArrayInput ( see symfony/console documentation for details );","title":"InputMapperInterface"},{"location":"command-chains/#example","text":"The initial section of this page [ 'name' => 'module', // adds \"module\" argument to the next command call with the value of \"name\" argument from the previous command '--mode' => '--type', // adds \"--type\" option to the next command call with the value of \"--mode\" option from the previous command ['additional-arg' => 'arg-value'], // adds \"additional-arg\" argument to the next command call with the value \"arg-value\" ['--additional-opt' => 'opt-value'], // adds \"--additional-opt\" option to the next command call with the value \"opt-value\" ], It is also possible to provide class name (string) which implements Laminas\\Cli\\Input\\Mapper\\InputMapperInterface if you need more customised mapper between input of the previous and next command.","title":"Example"},{"location":"command-params/","text":"Command Params The Symfony Console component allows commands to define input arguments and options . The laminas-cli package adds a third possibility, input parameters , which allow you to define command options that will become interactive prompts when omitted during command invocation. Using input parameters Internally, input parameters behave like standard options with the following modifications: Input parameters are optional by default. In interactive mode, when retrieving a parameter value that was not provided as an option, the user will be asked to provide the value. In non-interactive mode, if the user does not supply the option during invocation, and the parameter is not marked as required, its default value will be used; otherwise, an exception will be thrown, If the parameter has validations or normalizations supplied, these will be applied regardless of whether the option is provided during invocation or when the user is prompted to provide it. If the user provides a value via a prompt, that value will be stored as an input option so it can be passed to the next command in the chain (if one is defined). Input parameter types Input parameters are classes that implement Laminas\\Cli\\Input\\InputParamInterface : namespace Laminas\\Cli\\Input; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Question\\Question; interface InputParamInterface { /** * Default value to use if none provided. * * @return null|mixed */ public function getDefault(); public function getDescription(): string; public function getName(): string; /** * Return the Symfony\\Component\\Console\\Input\\InputOption::VALUE_* type. */ public function getOptionMode(): int; public function getShortcut(): ?string; public function getQuestion(): Question; public function isRequired(): bool; /** * @param mixed $defaultValue */ public function setDefault($defaultValue): self; public function setDescription(string $description): self; public function setShortcut(string $shortcut): self; public function setRequiredFlag(bool $required): self; } We provide the abstract class Laminas\\Cli\\Input\\AbstractInputParam to implement the majority of the methods in the interface; the only items you need to fill in are: getQuestion() : Each parameter type will define its own Question to return. protected $optionMode , which is set to Symfony\\Component\\Console\\Input\\InputOption::VALUE_REQUIRED by default. The constructor has one required parameter, a string $name ; you will need to call parent::__construct($name) if you override the constructor (e.g., to supply other required arguments). Many input types can likely allow multiple values. For example, if you have a --path option where you want to allow the user to supply a set of paths on which to perform an operation, or a --class operation to allow the user to specify multiple clases to generate. In those scenarios, we provide a trait, Laminas\\Cli\\Input\\AllowMultipleTrait , which defines a single method: public function setAllowMultipleFlag(bool $flag): self This method will update the $optionMode mask to either include or remove the InputOption::VALUE_IS_ARRAY bit. Compose it in your custom param implementations if you want to allow users the ability to specify more than one value for a parameter. Another trait, Laminas\\Cli\\Input\\StandardQuestionTrait , provides the method createQuestion() , which returns a Symfony\\Component\\Console\\Question\\Question instance with a prompt in the form of: <question>{description}</question> [<comment>{default}</comment>]: > This allows an implementation to use the standard format question, and then add things such as normalizers , validators , or autocompletion . Additionally, when the option mode includes InputOption::VALUE_IS_ARRAY (per the setAllowMultipleFlag() method as described previously), the application will prompt for multiple values using the same question and default value (if a default is available) until the user presses Return without entering anything. You can compose this trait in your own input param implementations, and call it from your getQuestion() method if that question format will work for you. Standard input parameter types We ship several standard input parameter types for use in your applications. All parameters require the parameter name as the initial argument, and additional arguments as specified below. All parameter types EXCEPT the BoolParam compose the AllowMultipleTrait , exposing the setAllowMultipleFlag() flag. Additionally, when writing validators, you do not need to check if the value is not required and an empty value submitted; ParamAwareInputInterface::getParam() does this for you. BoolParam Laminas\\Cli\\Input\\BoolParam allows specifying a parameter with a boolean value. It emits a Symfony\\Component\\Console\\Question\\ConfirmationQuestion . namespace Laminas\\Cli\\Input; final class BoolParam extends AbstractInputParam { public function __construct(string $name); } ChoiceParam Laminas\\Cli\\Input\\ChoiceParam allows specifying a set of choices from which the user may select a value, emitting a Symfony\\Component\\Console\\Question\\ChoiceQuestion . namespace Laminas\\Cli\\Input; final class ChoiceParam extends AbstractInputParam { use StandardQuestionTrait; public function __construct(string $name, array $haystack); } IntParam Laminas\\Cli\\Input\\IntParam allows specifying that a value must be an integer, and optionally be more than a minimum value and/or less than a maximum value. namespace Laminas\\Cli\\Input; final class IntParam extends AbstractInputParam { use StandardQuestionTrait; public function __construct(string $name); public function setMin(?int $min): self; public function setMax(?int $max): self; } PathParam Laminas\\Cli\\Input\\PathParam allows specifying that a value must be a path on the filesystem, requiring that you specifiy which, and optionally requiring that it exist. namespace Laminas\\Cli\\Input; final class PathParam extends AbstractInputParam { use StandardQuestionTrait; public const TYPE_DIR = 'dir'; public const TYPE_FILE = 'file'; /** * @param string $pathType One of the TYPE_* constants, indicating whether * the path expected should be a directory or a file. */ public function __construct(string $name, string $pathType); public function setPathMustExist(bool $flag): self; } StringParam Laminas\\Cli\\Input\\StringParam allows specifying that a value must be a string, and optionally match a PCRE regex. namespace Laminas\\Cli\\Input; final class StringParam extends AbstractInputParam { use StandardQuestionTrait; public function __construct(string $name); /** * @param string $pattern A valid PCRE regex pattern. */ public function setPattern(string $pattern): self; } Adding input parameters to a command In order to define input parameters in your command, your command will need to extend Laminas\\Cli\\Command\\AbstractParamAwareCommand . That class class extends Symfony\\Component\\Console\\Command\\Command and provides one additional method, addParam() , for adding an input parameter. The method accepts a single parameter, a Laminas\\Cli\\Input\\InputParamInterface instance. As an example, the following command adds a \"name\" parameter that expects a string: use Laminas\\Cli\\Command\\AbstractParamAwareCommand; use Laminas\\Cli\\Input\\ParamAwareInputInterface; use Laminas\\Cli\\Input\\StringParam; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; final class HelloCommand extends AbstractParamAwareCommand { /** @var string */ public static $defaultName = 'example:hello'; protected function configure() : void { $this->setName(self::$defaultName); $this->addParam( (new StringParam('name')) ->setDescription('Your name') ->setShortcut('n') ); } /** * @param ParamAwareInputInterface $input */ protected function execute(InputInterface $input, OutputInterface $output) : int { $name = $input->getParam('name'); $output->writeln('Hello ' . $name . '!'); return 0; } } ParamAwareInputInterface Internally, we decorate the input instance from the application with a class implementing our own ParamAwareInputInterface . This interface extends each of Symfony\\Component\\Console\\Input\\InputInterface and StreamableInputInterface , and adds the method getParam(string $name) for retrieving the input parameter. To ensure IDE completion and static analysis work as expected, you should typehint the $input argument as a ParamAwareInputInterface via a parameter annotation. (You cannot do so via type hint, as it would break compatibility with the AbstractCommand signature.) Adding parameters is similar to adding arguments or options, with one key difference: you provide an instance, instead of a series of values. The InputParamInterface and the various concrete implementations define builder methods that return $this , allowing you to create the instances in-line in a declarative manner. Accessing the parameter value is exactly like accessing an option or argument. However, unlike those items, parameters will prompt for values if they are missing. Let's see what happens when we call the command without the parameter: $ vendor/bin/laminas example:hello Your name: > Michal Hello Michal! If we provide the param value as an option during invocation: $ vendor/bin/laminas example:hello --name=Michal Hello Michal! As you can see, there is no prompt! AbstractParamAwareCommand::run The AbstractParamAwareCommand class overrides the symfony/console Command::run() method internally in order to decorate the input in a ParamAwareInputInterface implementation. If you decide you need to override the method yourself you MUST add one of the following lines within your implementation: // If you will be calling the parent run() method: parent::run($input, $output); // If you will not be calling the parent run() method: $input = $this->decorateInputToBeParamAware($input, $output); Creating custom parameter types If none of the standard input parameter types satisfy your use case, you can define a custom parameter type. As an example: use Laminas\\Cli\\Input\\AbstractInputParam; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Question\\Question; class CustomParam extends AbstractInputParam { public function getQuestion(): Question { $customQuestion = new Question('Please provide value for custom parameter:'); // some question modifications, like: $customQuestion->setValidator(static function (string $value) { /* ... */ }); $customQuestion->setAutocompleterCallback(static function (string $answer) { /* ... */ }); $customQuestion->setNormalizer(static function (string $answer) { /* ... */ }); // etc... return $question; } } In your command, you would then add it: $this->addParam( (new CustomParam('custom')) ->setDescription('Custom parameter') ->setRequiredFlag(true) ); Alternately, you could define it as an anonymous class implementation, inline where you add the parameter: $this->addParam( (new class('custom') extends \\Laminas\\Cli\\Input\\AbstractInputParam { public function getQuestion(): Question { $customQuestion = new Question('Please provide value for custom parameter:'); // some question modifications, like: $customQuestion->setValidator(static function (string $value) { /* ... */ }); $customQuestion->setAutocompleterCallback(static function (string $answer) { /* ... */ }); $customQuestion->setNormalizer(static function (string $answer) { /* ... */ }); // etc... return $question; } } ) ->setDescription('Custom parameter') ->setRequiredFlag(true) );","title":"Command Params"},{"location":"command-params/#command-params","text":"The Symfony Console component allows commands to define input arguments and options . The laminas-cli package adds a third possibility, input parameters , which allow you to define command options that will become interactive prompts when omitted during command invocation.","title":"Command Params"},{"location":"command-params/#using-input-parameters","text":"Internally, input parameters behave like standard options with the following modifications: Input parameters are optional by default. In interactive mode, when retrieving a parameter value that was not provided as an option, the user will be asked to provide the value. In non-interactive mode, if the user does not supply the option during invocation, and the parameter is not marked as required, its default value will be used; otherwise, an exception will be thrown, If the parameter has validations or normalizations supplied, these will be applied regardless of whether the option is provided during invocation or when the user is prompted to provide it. If the user provides a value via a prompt, that value will be stored as an input option so it can be passed to the next command in the chain (if one is defined).","title":"Using input parameters"},{"location":"command-params/#input-parameter-types","text":"Input parameters are classes that implement Laminas\\Cli\\Input\\InputParamInterface : namespace Laminas\\Cli\\Input; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Question\\Question; interface InputParamInterface { /** * Default value to use if none provided. * * @return null|mixed */ public function getDefault(); public function getDescription(): string; public function getName(): string; /** * Return the Symfony\\Component\\Console\\Input\\InputOption::VALUE_* type. */ public function getOptionMode(): int; public function getShortcut(): ?string; public function getQuestion(): Question; public function isRequired(): bool; /** * @param mixed $defaultValue */ public function setDefault($defaultValue): self; public function setDescription(string $description): self; public function setShortcut(string $shortcut): self; public function setRequiredFlag(bool $required): self; } We provide the abstract class Laminas\\Cli\\Input\\AbstractInputParam to implement the majority of the methods in the interface; the only items you need to fill in are: getQuestion() : Each parameter type will define its own Question to return. protected $optionMode , which is set to Symfony\\Component\\Console\\Input\\InputOption::VALUE_REQUIRED by default. The constructor has one required parameter, a string $name ; you will need to call parent::__construct($name) if you override the constructor (e.g., to supply other required arguments). Many input types can likely allow multiple values. For example, if you have a --path option where you want to allow the user to supply a set of paths on which to perform an operation, or a --class operation to allow the user to specify multiple clases to generate. In those scenarios, we provide a trait, Laminas\\Cli\\Input\\AllowMultipleTrait , which defines a single method: public function setAllowMultipleFlag(bool $flag): self This method will update the $optionMode mask to either include or remove the InputOption::VALUE_IS_ARRAY bit. Compose it in your custom param implementations if you want to allow users the ability to specify more than one value for a parameter. Another trait, Laminas\\Cli\\Input\\StandardQuestionTrait , provides the method createQuestion() , which returns a Symfony\\Component\\Console\\Question\\Question instance with a prompt in the form of: <question>{description}</question> [<comment>{default}</comment>]: > This allows an implementation to use the standard format question, and then add things such as normalizers , validators , or autocompletion . Additionally, when the option mode includes InputOption::VALUE_IS_ARRAY (per the setAllowMultipleFlag() method as described previously), the application will prompt for multiple values using the same question and default value (if a default is available) until the user presses Return without entering anything. You can compose this trait in your own input param implementations, and call it from your getQuestion() method if that question format will work for you.","title":"Input parameter types"},{"location":"command-params/#standard-input-parameter-types","text":"We ship several standard input parameter types for use in your applications. All parameters require the parameter name as the initial argument, and additional arguments as specified below. All parameter types EXCEPT the BoolParam compose the AllowMultipleTrait , exposing the setAllowMultipleFlag() flag. Additionally, when writing validators, you do not need to check if the value is not required and an empty value submitted; ParamAwareInputInterface::getParam() does this for you.","title":"Standard input parameter types"},{"location":"command-params/#adding-input-parameters-to-a-command","text":"In order to define input parameters in your command, your command will need to extend Laminas\\Cli\\Command\\AbstractParamAwareCommand . That class class extends Symfony\\Component\\Console\\Command\\Command and provides one additional method, addParam() , for adding an input parameter. The method accepts a single parameter, a Laminas\\Cli\\Input\\InputParamInterface instance. As an example, the following command adds a \"name\" parameter that expects a string: use Laminas\\Cli\\Command\\AbstractParamAwareCommand; use Laminas\\Cli\\Input\\ParamAwareInputInterface; use Laminas\\Cli\\Input\\StringParam; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; final class HelloCommand extends AbstractParamAwareCommand { /** @var string */ public static $defaultName = 'example:hello'; protected function configure() : void { $this->setName(self::$defaultName); $this->addParam( (new StringParam('name')) ->setDescription('Your name') ->setShortcut('n') ); } /** * @param ParamAwareInputInterface $input */ protected function execute(InputInterface $input, OutputInterface $output) : int { $name = $input->getParam('name'); $output->writeln('Hello ' . $name . '!'); return 0; } }","title":"Adding input parameters to a command"},{"location":"command-params/#creating-custom-parameter-types","text":"If none of the standard input parameter types satisfy your use case, you can define a custom parameter type. As an example: use Laminas\\Cli\\Input\\AbstractInputParam; use Symfony\\Component\\Console\\Input\\InputOption; use Symfony\\Component\\Console\\Question\\Question; class CustomParam extends AbstractInputParam { public function getQuestion(): Question { $customQuestion = new Question('Please provide value for custom parameter:'); // some question modifications, like: $customQuestion->setValidator(static function (string $value) { /* ... */ }); $customQuestion->setAutocompleterCallback(static function (string $answer) { /* ... */ }); $customQuestion->setNormalizer(static function (string $answer) { /* ... */ }); // etc... return $question; } } In your command, you would then add it: $this->addParam( (new CustomParam('custom')) ->setDescription('Custom parameter') ->setRequiredFlag(true) ); Alternately, you could define it as an anonymous class implementation, inline where you add the parameter: $this->addParam( (new class('custom') extends \\Laminas\\Cli\\Input\\AbstractInputParam { public function getQuestion(): Question { $customQuestion = new Question('Please provide value for custom parameter:'); // some question modifications, like: $customQuestion->setValidator(static function (string $value) { /* ... */ }); $customQuestion->setAutocompleterCallback(static function (string $answer) { /* ... */ }); $customQuestion->setNormalizer(static function (string $answer) { /* ... */ }); // etc... return $question; } } ) ->setDescription('Custom parameter') ->setRequiredFlag(true) );","title":"Creating custom parameter types"},{"location":"intro/","text":"Introduction laminas-cli is a command-line interface for Laminas projects. It provides seamless integration with Laminas MVC and Mezzio applications. Both third-party packages and your own application can extend it by writing commands and exposing them to the laminas-cli binary via configuration. Integrating in components If you'd like to add integration with laminas-cli into your components, you will need to do the following: Add laminas/laminas-cli as a dev dependency: $ composer require --dev laminas/laminas-cli Create a command class in your library: namespace MyNamespace\\Command; use Symfony\\Component\\Console\\Command\\Command; class MyCommand extends Command { // ... } If your command has dependencies, register the command and its factory in the container. Commands that can be instantiated with no constructor arguments can omit container configuration: // config/autoload/dependencies.global.php: return [ 'dependencies' => [ 'factories' => [ MyNamespace\\Command\\MyCommand::class => MyNamespace\\Command\\MyCommandFactory::class, ], ], ]; Register the command with the CLI tooling: // config/autoload/global.php: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyNamespace\\Command\\MyCommand::class, ], ], ]; If your component is providing a ConfigProvider (such as in Mezzio applications), please provide the configuration in that class instead: namespace MyNamespace; class ConfigProvider { public function __invoke() : array { return [ 'laminas-cli' => $this->getCliConfig(), 'dependencies' => $this->getDependencyConfig(), ]; } public function getCliConfig() : array { return [ 'commands' => [ 'package:command-name' => Command\\MyCommand::class, ], ]; } public function getDependencyConfig() : array { return [ 'factories' => [ Command\\MyCommand::class => Command\\MyCommandFactory::class, ], ]; } } If you want to provide a Module class for Laminas MVC, provide a ConfigProvider as noted above, and then add the following Module class declaration: namespace MyNamespace; class Module { public function getConfig() : array { $configProvider = new ConfigProvider(); return [ 'laminas-cli' => $configProvider->getCliConfig(), 'service_manager' => $configProvider->getDependencyConfig(), ]; } } Integration in Other Applications laminas-cli supports Laminas MVC and Mezzio applications out of the box. If you want to use the tool with a different application type, or you have modified the default configuration and your PSR-11 container cannot be detected automatically, you can still use the laminas-cli tool. To integrate such applications with laminas-cli, you will need to create a file that returns a PSR-11 container. Do so in the file config/container.php . Such a file might look like the following: <?php // File config/container.php declare(strict_types=1); use JSoumelidis\\SymfonyDI\\Config\\Config; use JSoumelidis\\SymfonyDI\\Config\\ContainerFactory; $config = require realpath(__DIR__) . '/../var/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); Once such a file is in place, the laminas-cli binary will be able to use your container to seed its application. Usage To list all available commands, run: $ ./vendor/bin/laminas To execute a specific command, run: $ ./vendor/bin/laminas <command-name> To get help on a single command, run: $ ./vendor/bin/laminas help <command-name>","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-cli is a command-line interface for Laminas projects. It provides seamless integration with Laminas MVC and Mezzio applications. Both third-party packages and your own application can extend it by writing commands and exposing them to the laminas-cli binary via configuration.","title":"Introduction"},{"location":"intro/#integrating-in-components","text":"If you'd like to add integration with laminas-cli into your components, you will need to do the following: Add laminas/laminas-cli as a dev dependency: $ composer require --dev laminas/laminas-cli Create a command class in your library: namespace MyNamespace\\Command; use Symfony\\Component\\Console\\Command\\Command; class MyCommand extends Command { // ... } If your command has dependencies, register the command and its factory in the container. Commands that can be instantiated with no constructor arguments can omit container configuration: // config/autoload/dependencies.global.php: return [ 'dependencies' => [ 'factories' => [ MyNamespace\\Command\\MyCommand::class => MyNamespace\\Command\\MyCommandFactory::class, ], ], ]; Register the command with the CLI tooling: // config/autoload/global.php: return [ 'laminas-cli' => [ 'commands' => [ 'package:command-name' => MyNamespace\\Command\\MyCommand::class, ], ], ]; If your component is providing a ConfigProvider (such as in Mezzio applications), please provide the configuration in that class instead: namespace MyNamespace; class ConfigProvider { public function __invoke() : array { return [ 'laminas-cli' => $this->getCliConfig(), 'dependencies' => $this->getDependencyConfig(), ]; } public function getCliConfig() : array { return [ 'commands' => [ 'package:command-name' => Command\\MyCommand::class, ], ]; } public function getDependencyConfig() : array { return [ 'factories' => [ Command\\MyCommand::class => Command\\MyCommandFactory::class, ], ]; } } If you want to provide a Module class for Laminas MVC, provide a ConfigProvider as noted above, and then add the following Module class declaration: namespace MyNamespace; class Module { public function getConfig() : array { $configProvider = new ConfigProvider(); return [ 'laminas-cli' => $configProvider->getCliConfig(), 'service_manager' => $configProvider->getDependencyConfig(), ]; } }","title":"Integrating in components"},{"location":"intro/#integration-in-other-applications","text":"laminas-cli supports Laminas MVC and Mezzio applications out of the box. If you want to use the tool with a different application type, or you have modified the default configuration and your PSR-11 container cannot be detected automatically, you can still use the laminas-cli tool. To integrate such applications with laminas-cli, you will need to create a file that returns a PSR-11 container. Do so in the file config/container.php . Such a file might look like the following: <?php // File config/container.php declare(strict_types=1); use JSoumelidis\\SymfonyDI\\Config\\Config; use JSoumelidis\\SymfonyDI\\Config\\ContainerFactory; $config = require realpath(__DIR__) . '/../var/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); Once such a file is in place, the laminas-cli binary will be able to use your container to seed its application.","title":"Integration in Other Applications"},{"location":"intro/#usage","text":"To list all available commands, run: $ ./vendor/bin/laminas To execute a specific command, run: $ ./vendor/bin/laminas <command-name> To get help on a single command, run: $ ./vendor/bin/laminas help <command-name>","title":"Usage"}]}